{
	"label": {
		"cim": "Algorithms step-by-step",
		"oldalleirasa": "",
		"pszeudokod": "Pseudocode",
		"struktogram": "Structogram",
		"cppimplementacio": "C++ implementation",
		"leiras": "Description",
		"bovebben": "More information",
		"projecttitle": "Algorithms step-by-step",
		"tartalomjegyzek": "Contents",
		"keszitette": "Made by",
		"temavezeto": "Tutor",
		"futtatas": "Run",
		"feltetel": "Condition",	
		"hibasbemenet": "Wrong input",
		"valtozokertekei": "Variables",
		"tomballasa": "Array status",
		"valtozas": "Changed:",
		"menu": {
			"kezdooldal": "Homepage",
			"progtetelek": "Basic algorithms<span class='caret'></span>",
			"rendezesek": "Sorts<span class='caret'></span>",
			"grafalgoritmusok": "Graph algorithms<span class='caret'></span>",
			"adatszerkezetek": "Data structures<span class='caret'></span>",
			"egyeb": "Other<span class='caret'></span>"
		},
		"fooldal": {
			"kezdooldal": "Homepage",
			"progtetelek": "Basic algorithms",
			"rendezesek": "Sorts",
			"grafalgoritmusok": "Graph algorithms",
			"adatszerkezetek": "Data structures",
			"egyeb": "Other"
		},
		"cppPelda": "C++ example",
		"dokumentacio": "Documentation"
	},
	"pszeudokodelem": {
		"ha": "If",
		"amig": "While",
		"kulonben": "Else",
		"kulonbenha": "Else if",
		"ciklus": "For",
		"ciklusamig": "While",
		"akkor": "then",
		"eljaras": "Procedure",
		"kiiras": "Print",
		"elagazasvege": "End If",
		"ciklusvege": "End For",
		"eljarasvege": "End Procedure",
		"es": "and",
		"vagy": "or"
	},
	"progtetel": {
		"osszegzes": {
			"leiras": "Ez a tétel N darab „valami” közül kell megadja a legnagyobbat (vagy a legkisebbet).<br/>Kell: Értelmezve legyen egy rendezési reláció, legalább egy elem legyen!",
			"nev": "Sum"
		},
		"megszamolas": {
			"leiras": "A megszámolás tétel egy tömb elemei között megszámlálja a T tulajdonsággal rendelkezőket. T egy tetszőleges tulajdonságfüggvényt jelent, egy sorozatbeli elemre nézve lehet igaz vagy hamis.",
			"nev": "Count"
		},
		"maxkiv": {
			"leiras": "Ez a tétel N darab „valami” közül kell megadja a legnagyobbat (vagy a legkisebbet).<br/>Kell: Értelmezve legyen egy rendezési reláció, legalább egy elem legyen!",
			"nev": "Maximum selection"
		},
		"kereses": {
			"leiras": "A megszámolás tétel egy tömb elemei között megszámlálja a T tulajdonsággal rendelkezőket. T egy tetszőleges tulajdonságfüggvényt jelent, egy sorozatbeli elemre nézve lehet igaz vagy hamis.",
			"nev": "Search"
		},
		"logker": {
			"leiras": "A megszámolás tétel egy tömb elemei között megszámlálja a T tulajdonsággal rendelkezőket. T egy tetszőleges tulajdonságfüggvényt jelent, egy sorozatbeli elemre nézve lehet igaz vagy hamis.",
			"nev": "Logarithmic search"
		},
		"masolas": {
			"leiras": "Egy sorozat elemet átmásolom egy másik sorozatba, miközben valamilyen átalakítást végzek az egyes elemeken.",
			"nev": "Copy"
		},
		"kivalogatas": {
			"leiras": "A tömb elemit egy másik tömbbe rakom, feltételhez kötve.",
			"nev": "Select"
		},
		"szetvalogatas": {
			"leiras": "Két tömbbe válogatjuk szét egy tömb elemeit.",
			"nev": "Separate"
		},
		"unio": {
			"leiras": "Union of two arrays.",
			"nev": "Union"
		},
		"metszet": {
			"leiras": "Intersection of two arrays.",
			"nev": "Intersection"
		}
	},
	"rendezes": {
		"buborekos": {
			"leiras": "Bubble sort is a simple sorting algorithm. This sorting algorithm is comparison-based algorithm in which each pair of adjacent elements is compared and the elements are swapped if they are not in order.",
			"nev": "Bubble sort"
		},
		"minkiv": {
			"leiras": "Selection sort is a simple sorting algorithm. This sorting algorithm is an in-place comparison-based algorithm in which the list is divided into two parts, the sorted part at the left end and the unsorted part at the right end.",
			"nev": "Selection sort"
		},
		"gyorsrendezes": {
			"leiras": "Quick sort is a highly efficient sorting algorithm and is based on partitioning of array of data into smaller arrays. A large array is partitioned into two arrays one of which holds values smaller than the specified value, say pivot, based on which the partition is made and another array holds values greater than the pivot value.",
			"nev": "Quick sort"
		},
		"osszefesulesesrendezes": {
			"leiras": "Merge sort is a sorting technique based on divide and conquer technique. With worst-case time complexity being Ο(n log n), it is one of the most respected algorithms.",
			"nev": "Merge sort"
		}
	},
	"adatszerkezet": {
		"sor": {
			"nev": "Queue",
			"muvelet": {
				"sorbol": "Dequeue",
				"sorba": "Enqueue",
				"urese": "Is empty?",
				"telie": "Is full?",
				"elso": "Front"
			}
		},
		"verem": {
			"nev": "Stack",
			"muvelet": {
				"verembol": "Pop",
				"verembe": "Push",
				"urese": "Is empty?",
				"telie": "Is full?",
				"elso": "Front"
			}
		}
	},
	"egyeb": {
		"faktorialis": {
			"leiras": "Calculate the N factorial (N!).",
			"nev": "Factorial"
		}
	}
}